# -*- coding: utf-8 -*-
"""Важно.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wtLHJv-0_gxovwxg1Y0K-FlFFtf7PoEW
"""

from tqdm.notebook import tqdm
from datetime import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from math import pi
import matplotlib.colors as mcolors
import collections
import xml.etree.ElementTree as ET

!wget -c https://repo.continuum.io/miniconda/Miniconda3-py37_4.8.3-Linux-x86_64.sh
!chmod +x Miniconda3-py37_4.8.3-Linux-x86_64.sh
!time bash ./Miniconda3-py37_4.8.3-Linux-x86_64.sh -b -f -p /usr/local
!time conda install -q -y -c conda-forge rdkit

import sys
sys.path.append('/usr/local/lib/python3.7/site-packages/')

from rdkit import Chem
from rdkit.Chem.Draw import IPythonConsole

tree = ET.parse('/content/drive/My Drive/full_database.xml')
root = tree.getroot()

ALL_FUNC_GROUP = {
'NH2': '[NX3;H2,H1;!$(NC=O)]', 
'C=O': '[CX3]=[OX1]', 
'C(O)NH2': '[NX3][CX3](=[OX1])[#6]', 
'NO': '[NX2]=[OX1]', 
'NO2': '[$([NX3](=O)=O),$([NX3+](=O)[O-])][!#8]'
}

DICT_OF_MOLS = {'years': [], 'func_group': []}

PREFIX = '{http://www.drugbank.ca}'

mols_w_func_group = {}
all_mols = {}
output = []

print('Please, print your functiounal group.')
FUNC_GROUP = input()

if not ALL_FUNC_GROUP.get(FUNC_GROUP):
  print('Functional group not identified.')
else:
  FUNC_GROUP_GROUP =  ALL_FUNC_GROUP[FUNC_GROUP]

for child in tqdm(root.getchildren()):
 
    cp = child.find(f'{PREFIX}calculated-properties')
    pt = child.find(f'{PREFIX}patents')
    list_of_dates = []
    SMILES = None
    if not cp: 
      continue
 
    for child_ in cp.getchildren():
        if (child_.find(f'{PREFIX}kind').text == 'SMILES'): 
            SMILES = child_.find(f'{PREFIX}value').text
 
    if SMILES is None:
      continue
      
    for child_ in pt.getchildren():
      for child__ in child_.getchildren():
 
        if not child__.tag:
          continue
          
        if child__.tag == (f'{PREFIX}approved') and child__.text is not None:
 
          DATE_PAT = datetime.strptime(child__.text, '%Y-%m-%d')
          DATE_PAT = int(datetime.strftime(DATE_PAT, '%Y'))
          list_of_dates.append(DATE_PAT)
 
    if len(list_of_dates) != 0:
 
      min_date = min(list_of_dates)
      mol = Chem.MolFromSmiles(SMILES)
 
      if not mol:
        display(SMILES)
        continue
 
      functional_group = Chem.MolFromSmarts(FUNC_GROUP_GROUP)
      matches = mol.GetSubstructMatches(functional_group)
      DICT_OF_MOLS['years'].append(min_date)
 
      if len(matches) > 0:
        DICT_OF_MOLS['func_group'].append(1)
      else:
        DICT_OF_MOLS['func_group'].append(0)

df = pd.DataFrame(DICT_OF_MOLS)
 
for x in np.unique(df['years'].values):
  mols_w_func_group[x] = ((df['years'] == x) & (df['func_group'] == 1)).sum()
  all_mols[x] = (df['years'] == x).sum()

mols_w_func_group = collections.OrderedDict(sorted(mols_w_func_group.items()))
all_mols = collections.OrderedDict(sorted(all_mols.items()))

count_mols = list(all_mols.values())
count_w_func_group = list(mols_w_func_group.values())
year = list(mols_w_func_group.keys())

for a,b in zip(count_w_func_group, count_mols):
  output.append(a/b)

plt.figure(figsize=(15, 15))
plt.xlabel('years')
plt.ylabel(f'per cent with {FUNC_GROUP} in this year')
plt.title(FUNC_GROUP)
plt.scatter(range(min(year),len(mols_w_func_group)+min(year)), output, s=50)
plt.show()